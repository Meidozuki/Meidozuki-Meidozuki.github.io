# 排序

### 交换

交换变量a,b有以下方法

1. 临时变量  
    > t=a; a=b; b=t;
    > 
    > STL中的std::swap()就是这种方法，这种方法通用且容易理解
2. 基础数据位运算^=  
    > a^=b^=a^=b;
    >
    > 仅限基础数据，并且需要&a != &b，否则第一步之后就变成0了
3. 代数运算法
    > 在高代证明*交换行列式两行行列式不变*时用到过
    > 
    > a+=b; b-=a; b=-b; a-=b;
    >
    > 同样需要&a != &b,否则在第二步就变成0了

以下排序均用std::swap来进行交换。由于升序和降序排序没有本质区别且易相互转换，以下以升序排序为例。

## 冒泡排序

```
@loop_n_times
def f():
    for i in range(1,n):
        if a[i] < a[i-1]:
            swap()
```

冒泡排序过程中，每一趟会交换出最大值到右边，并且沿途也可能会发生交换

最差情况为原本即为逆序排列，这时每一趟相当于仅把最左边的元素“搬运”到最右边，比较次数=$n^2$

## 选择排序

```
for i in range(0,n):
    swap(a[i],real_i_th_element())
```

选择排序每次仅在当前无序序列中选择一个最值（如最大值）放到两端（如最右边）

最差情况也为原本即为逆序排列，比较次数=$n^2$

选择排序由于每次仅交换一个最大值，对于其他位置，不改变局部单调性。

选择排序推荐在数据类型$time(Copy) \gt time(Compare)$时使用

## 插入排序

```
for i in range(1,n):
    insert_sort(0,i)
```

插入排序每次将有序序列长度扩大1，对于新加入的元素a[i]，小于它的元素不动，大于它的元素右移一格，然后插入a[i]。该过程如同扑克牌插入牌一样因此称为插入排序

最差情况也为原本即为逆序排列，比较次数=$n^2$

插入排序利用了局部有序性，因此可以在子序列比较时提前停止。每次插入时相当于一次改进的冒泡算法，在a[i]左边只有比较没有交换，a[i]右边不比较仅腾出空间，相比于冒泡排序减少了比较次数。

插入排序在简单数据的实际测试中是3种简单排序算法中相对高效的。

## 简单排序算法的分析

基于邻位比较算法（冒泡和插入）的最差时间复杂度不会低于$O(n^2)$

将待排序视为一个排列(permutation)，其最大的逆序数为$1+2+3+...+n-1={n^2+n \over 2}$，平均逆序数为${n^2+n \over 4}$。而一次相邻元素的交换只能使逆序数-1，因此平均需要${n^2+n \over 4}=$O(n^2)$次比较

### 简单排序算法的优化

## 希尔排序

希尔排序算法的时间复杂度不仅与待排序序列有关，还与增长序列的选取有关，希尔排序的平均复杂度分析极为复杂，希尔排序的最差时间复杂度为$O(n^{1.3})$~$O(n^2)$

## 堆排序

## 归并排序

## 快速排序

## 通用排序算法的$nlogn$下界

## 基数排序