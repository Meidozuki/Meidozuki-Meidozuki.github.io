---
layout: page
permalink: /4/
---

# 4-散列

上一节我们提到，为了达到访问效率为O(logn)，我们引入了二叉树。二叉树的最差访问效率为O(n)，平均访问效率为O(logn)。这一节我们更近一步，介绍一种经典的以空间换时间的数据结构——散列，或者哈希表(hash table)，它的平均访问效率为O(1)

## 散列

散列通常用在字符串中，比如"Hello world"通过SHA-1得到的哈希值为`7B502C3A1F48C8609AE212CDFB639DEE39673F5E`

为了简单起见，我们暂时把散列用在比较小的数字上，体会一下散列的核心思想

## 散列表的相关概念

例如，我们选取散列函数为`lambda x: x%7`（即f(x)=x mod 7），选取表长11，依次插入1，13，50，40，可以得到下图所示结构

![](img/hash.dot.jpg)

1. 关键字(key)：待插入的元素的原始数据，如本例中的1，40，50
2. 散列函数/哈希函数(hash function)：将关键字映射为地址的函数，形如Addr=H(key)，其中H为散列函数。如本例中为f(x)=x mod 7。散列函数的好坏对于散列的性能有着至关重要的影响。散列函数映射出的地址也叫哈希值
3. 散列表长(table size)：散列表最多能容纳的关键字个数，很多情况下散列表长就等于散列函数可能的结果数（如本例中为7），但也可以不同
4. 碰撞(collision)：当遇到两个哈希值相同的关键字时，我们称发生了一次碰撞。如本例中，1和50的哈希值都是1，他们就发生了碰撞。因为碰撞的存在，散列表的结果和插入顺序是息息相关的。下文将会介绍两种碰撞处理的方法，本例中用的是开放寻址法
5. 载荷因子(load factor)：(假设表长和散列函数结果数相同)载荷因子=表中已有的元素个数/表长。当表中已有元素个数很多时，发生碰撞的概率会大大增加，因此在实际应用中我们可以通过载荷因子来提前调整散列表(如再散列Rehashing)

## 碰撞处理

我们介绍两种简单的碰撞处理方法，拉链法和开放寻址法

### Seperate Chaining

### Open Addressing

线性探测

平方探测

双散列法

## 再散列Rehashing

当散列表中已有元素个数很多时，发生碰撞的概率会大大增加。为了减轻后续可能发生的碰撞，我们可以通过增大表长，将已有元素重新散列一次的方法来减小载荷因子。

但是再散列需要花费O(n)的时间，对于实时性要求很高的场景（如医疗航天等），再散列的过程中可能会发生不可挽回的情况。这种情况下更推荐用拉链法